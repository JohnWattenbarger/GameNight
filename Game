import pygame, sys
from pygame.locals import *
import random

# center the window
import os
os.environ['SDL_VIDEO_CENTERED'] = '1'

pygame.init()

# Set up screen
WIDTH = 800
HEIGHT = 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
backgroundColor = (100, 220, 230)
backgroundColor = (0, 20, 25)

# Setup player
playerWidth = 50
playerHeight = 50

playerX = WIDTH//2
playerY = HEIGHT - 1.5*playerHeight

playerColor = (245, 50, 50)
playerSpeed = 8

# Setup enemies
enemyColumns = 8
enemyRows = 3

enemyWidth = WIDTH / (enemyColumns) / 2
enemyHeight = 40

enemySpeed = 5
enemyColor = (50, 250, 50)

enemyGap = enemyWidth

# 1 / chanceToShoot  is the % likelihood that each enemy will shoot per frame
chanceToShoot = 100

    # create list of enemies
enemies = []

# create a list of bullets
bulletWidth = 5
bulletHeight = 10
bulletColor = (255, 255, 255)
bulletSpeed = 10

playerBullets = []
enemyBullets = []

# keep track of player shot delay
currentShootAgainDelay = 0
shootAgainResetValue = 10

# keep track of time passing
time = 0

# create an enemy object to keep track of different attributes
class Component():
    def __init__(self, x, y, width, height, speed, color):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.speed = speed
        self.color = color

        self.points = []

        # self.rect = (x, y, width, height)

        # used to rotate in a circle
        self.startingX = x
        self.startingY = y

        self.moveDistance = 50
        self.nextPoint = 0

        self.setupRotatingPoints()

    def moveTowards(self, newX, newY):
        if self.x < newX:
            self.x += self.speed
        elif self.x > newX:
            self.x -= self.speed

        if self.y < newY:
            self.y += self.speed
        elif self.y > newY:
            self.y -= self.speed

    def setupRotatingPoints(self):
        self.points.append((self.startingX, self.startingY))
        self.points.append((self.startingX, self.startingY + self.moveDistance))
        self.points.append((self.startingX + self.moveDistance, self.startingY + self.moveDistance))
        self.points.append((self.startingX + self.moveDistance, self.startingY))

    def moveToNextPoint(self):
        # update next point
        if self.x == self.points[self.nextPoint][0] and self.y == self.points[self.nextPoint][1]:
            if self.nextPoint < len(self.points)-1:
                self.nextPoint += 1
            else:
                self.nextPoint = 0

        # move towards next point
        self.moveTowards(self.points[self.nextPoint][0], self.points[self.nextPoint][1])

        # if time < 100:
        #     self.moveTowards(self.points[self.nextPoint][0], self.points[self.nextPoint][1])
        # else:
        #     self.moveTowards(player.x, player.y)
    
    def getCenter(self):
        centerX = self.x + (self.width//2)
        centerY = self.y + (self.height // 2)
        return (centerX, centerY)
        
    def shoot(self, direction, list):
        x = self.getCenter()[0]
        y = self.getCenter()[1]
        
        if direction == 'up':
            speed = bulletSpeed * -1
        if direction == 'down':
            speed = bulletSpeed
        
        list.append(Component(x, y, bulletWidth, bulletHeight, speed, bulletColor))

    def moveBullet(self):
        self.y += self.speed

    def draw(self):
        pygame.draw.rect(screen, self.color, (self.x, self.y, self.width, self.height))

    def getRect(self):
        return pygame.Rect(self.x, self.y, self.width, self.height)

for col in range(0, enemyColumns):
    for row in range(0, enemyRows):
        # enemies.append(Component(col*enemyWidth + col*enemyGap + enemyWidth, row*enemyHeight + row*enemyGap + enemyHeight, enemyWidth, enemyHeight, enemySpeed, enemyColor))

        enemyX = col * enemyWidth + col * enemyGap
        enemyY = row * enemyHeight + row * enemyGap

        enemies.append(Component(enemyX, enemyY, enemyWidth, enemyHeight, enemySpeed, enemyColor))

# key presses
keyLeft = False
keyRight = False
keySpace = False

# clock
clock = pygame.time.Clock()

# create player
player = Component(playerX, playerY, playerWidth, playerHeight, playerSpeed, playerColor)

gameOver = False


while not gameOver:
    for event in pygame.event.get():
        # test
        # print(event)

        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                sys.exit()
            if event.key == pygame.K_LEFT:
                keyLeft = True
            if  event.key == pygame.K_RIGHT:
                keyRight = True
            if event.key == pygame.K_SPACE and currentShootAgainDelay == 0:
                keySpace = True

        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                keyLeft = False
            if  event.key == pygame.K_RIGHT:
                keyRight = False
            if event.key == pygame.K_SPACE:
                keySpace = False

    #update player position
    if keyLeft and player.x > 0:
        player.x -= player.speed
    if keyRight and player.x < WIDTH - playerWidth:
        player.x += player.speed

    # update player shooting
    if keySpace and currentShootAgainDelay == 0:
        player.shoot('up', playerBullets)
        currentShootAgainDelay = shootAgainResetValue

    # look for bullet collisions
    playerRect = player.getRect()
    for b in enemyBullets:
        if b.getRect().colliderect(playerRect):
            gameOver = True

    for b in playerBullets:
        for e in enemies:
            # if there is a collision
            if b.getRect().colliderect(e.getRect()):
                playerBullets.remove(b)
                enemies.remove(e)

    # draw graphics
    screen.fill(backgroundColor)

    # draw bullets
    for b in enemyBullets:
        b.moveBullet()
        b.draw()
    for b in playerBullets:
        b.moveBullet()
        b.draw()

    # draw player
    pygame.draw.rect(screen, player.color, (player.x, player.y, player.width, player.height))

    # draw enemies
    for e in enemies:
        e.moveToNextPoint()
        pygame.draw.rect(screen, e.color, (e.x, e.y, e.width, e.height))

        # determine if an enemy will shoot
        randomNumber = random.randrange(chanceToShoot)
        if randomNumber == 0:
            e.shoot('down', enemyBullets)


    pygame.display.update()

    # wait
    clock.tick(30)

    # used for score
    time += 1
    print(str(time) + '    ' + str(len(enemies)))

    # used for shooting delay
    if currentShootAgainDelay > 0:
        currentShootAgainDelay -= 1

    # end game if no enemies left
    if len(enemies) == 0:
        gameOver = True

while gameOver:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                sys.exit()

def randomColor():
    return (random.randrange(255), random.randrange(255), random.randrange(255))